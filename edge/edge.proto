syntax = "proto3";

package edge;

service Edge {
  rpc GetNodes (GetNodesRequest) returns (GetNodesReply) {}
  rpc ReadRows (ReadRowsRequest) returns (stream ReadRowsReply) {}
  rpc MakeTransformer (MakeTransformerRequest) returns (MakeTransformerReply) {}
  rpc GetIngresses (GetIngressesRequest) returns (GetIngressesReply) {}
}

message GetNodesRequest {} // possibly add a filter

message GetNodesReply {
    repeated string nodes = 1;
}

message GetIngressesRequest {
    string node = 1;
    // possibly add filters here, for now just get ALL
}

message GetIngressesReply {
    repeated string ingresses = 1;
}

message MakeTransformerRequest {
    string node = 1;
    // if set, then javascript transformer is created
    bytes javascript = 2;
}

message MakeTransformerReply {
    string id = 1;
}

message ReadRowsRequest {
    string node = 1;
    bytes start = 2;
    bytes end = 3;
    string transformer_id = 4;
    string accumulator = 5;
    // ReadRows will terminate after reading N rows worth of input. Note: transforms are not
    // 1:1 for input to output rows, so N rows of input may result in M rows of output.
    int64 limit = 6;
}

message ReadRowsReply {
    repeated string rows = 1;
    // optionally, the server might return the row key of the last completely scanned row.
    // This is so that a client may efficiently scan to where the request left off in a subsequent
    // call to ReadRows in the case where many rows were processed, but because of the transform, no
    // output was generated.
    bytes last_input_row = 2;
    // similar to last_input_row, the last_accumulator returns the last accumulator from a transform
    // of intput -> output. This combined with last_row allows a client to call ReadRows again
    // and pick up where the last call left off.
    string last_accumulator = 3;
}
